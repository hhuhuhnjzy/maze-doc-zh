.. _quick_start:

快速入门
========

本指南将引导您运行一个完整的 Maze 示例：**自动化报告生成工作流**。我们将使用 `test.py` 中的代码，演示如何定义任务、构建依赖关系图（DAG）、提交工作流，并获取最终结果。

该工作流包含以下四个任务：
1.  **创建初始报告**
2.  **添加分析章节**
3.  **添加总结章节**
4.  **整合并生成最终报告**

通过本示例，您将体验 Maze 的核心特性：**任务级调度**、**依赖自动解析** 和 **并行执行能力**。

前提条件
--------

请确保已完成 :ref:`installation` 中的所有步骤，包括：

- 已安装 `torch`、`ray` 等依赖
- 已执行 `pip install -r requirements.txt` 和 `pip install -e .`
- （服务器模式）已配置 `config/config.toml` 中的 `project_root`

步骤 1：定义任务函数
--------------------

在 Maze 中，每个计算步骤都通过 `@task` 装饰器定义为一个独立的任务。以下是本示例中的四个任务函数：

.. code-block:: python
   :linenos:

   from maze.library.tasks.definitions import task
   import time

   @task(
       name="create_initial_report",
       description="创建一个初始报告，作为工作流的起点。",
       task_type='cpu',
       input_parameters={"properties": {"reporter_name": {"type": "string"}}},
       output_parameters={"properties": {"report_content": {"type": "string"}}}
   )
   def create_report(reporter_name: str) -> str:
       print(f"--- 任务 [create_initial_report] 正在执行 ---")
       report = f"Initial report generated by {reporter_name}."
       print(f"--- 任务 [create_initial_report] 完成 ---")
       return report

   @task(
       name="add_analysis_section",
       description="在报告中添加分析章节。",
       task_type='cpu',
       input_parameters={"properties": {"base_report": {"type": "string"}}},
       output_parameters={"properties": {"updated_report": {"type": "string"}}}
   )
   def add_analysis(base_report: str) -> str:
       print(f"--- 任务 [add_analysis_section] 正在执行 ---")
       time.sleep(2)  # 模拟耗时的数据分析
       updated_report = base_report + "\nSection: Data Analysis - Analysis complete."
       print(f"--- 任务 [add_analysis_section] 完成 ---")
       return updated_report

   @task(
       name="add_summary_section",
       description="在报告中添加总结章节。",
       task_type='cpu',
       input_parameters={"properties": {"base_report": {"type": "string"}}},
       output_parameters={"properties": {"updated_report": {"type": "string"}}}
   )
   def add_summary(base_report: str) -> str:
       print(f"--- 任务 [add_summary_section] 正在执行 ---")
       time.sleep(3)  # 模拟耗时的总结生成
       updated_report = base_report + "\nSection: Summary - Summary complete."
       print(f"--- 任务 [add_summary_section] 完成 ---")
       return updated_report

   @task(
       name="finalize_report",
       description="整合所有章节，形成最终报告。",
       task_type='cpu',
       input_parameters={
           "properties": {
               "analysis_report": {"type": "string"},
               "summary_report": {"type": "string"}
           }
       },
       output_parameters={"properties": {"final_report": {"type": "string"}}}
   )
   def finalize_report(analysis_report: str, summary_report: str) -> str:
       print(f"--- 任务 [finalize_report] 正在执行 ---")
       final_report = f"--- FINAL REPORT ---\n{analysis_report}\n{summary_report.splitlines()[-1]}"
       print(f"--- 任务 [finalize_report] 完成 ---")
       return final_report
说明：

@task 装饰器用于注册任务，可指定名称、描述、资源类型（task_type）和输入/输出参数。
add_analysis 和 add_summary 通过 time.sleep() 模拟耗时操作，体现任务级调度的优势。
这两个任务可以并行执行，因为它们互不依赖。
步骤 2：创建客户端并定义工作流
使用 MazeClient 连接到 Maze 服务，并通过 new_workflow() 创建一个工作流对象。

.. code-block:: python

Maze客户端
print("🚀 [Step 1] Connecting to Maze Server...")
SERVER_ADDRESS = "127.0.0.1:6380"
client = MazeClient(server_address=SERVER_ADDRESS)
print("✅ [Step 1] Connection successful.\n")

创建workflow
print("🚀 [Step 2] Defining workflow blueprint...")
report_workflow = client.new_workflow(name="Simple Report Generation Workflow")


步骤 3：添加任务并定义依赖关系
------------------------------

使用 `add_task()` 方法将任务添加到工作流中，并通过 `{task_id}.output.{field}` 语法声明依赖。

.. code-block:: python

   # 1. 添加起始任务
   task_a_id = report_workflow.add_task(
       create_report,
       task_name="Create Initial Report",
       inputs={'reporter_name': 'MazeBot'}
   )

   # 2. 添加分析任务，依赖于起始任务的输出
   task_b_id = report_workflow.add_task(
       add_analysis,
       task_name="Add Analysis Section",
       inputs={'base_report': f'{task_a_id}.output.report_content'}
   )

   # 3. 添加总结任务，也依赖于起始任务的输出
   task_c_id = report_workflow.add_task(
       add_summary,
       task_name="Add Summary Section",
       inputs={'base_report': f'{task_a_id}.output.report_content'}
   )

   # 4. 添加最终任务，依赖于分析和总结任务的输出
   final_task_id = report_workflow.add_task(
       finalize_report,
       task_name="Finalize The Report",
       inputs={
           'analysis_report': f'{task_b_id}.output.updated_report',
           'summary_report': f'{task_c_id}.output.updated_report'
       }
   )

   print("✅ [Step 2] Workflow defined.\n")
说明：

task_a_id 是第一个任务的唯一标识符。
f'{task_a_id}.output.report_content' 表示该任务的输入依赖于 create_report 任务的输出字段 report_content。
由于 add_analysis 和 add_summary 都只依赖 create_report，它们将被 并行调度执行，节省总执行时间。
步骤 4：可视化工作流结构（可选）
------------------------------

您可以使用 `visualize()` 方法查看 DAG 的结构，便于调试和理解：

.. code-block:: python

   # 可视化工作流
   compact_style = {
       'figsize': (8, 6),
       'title_fontsize': 20,
       'node_size': 5000,
       'node_fontsize': 8,
       'edge_fontsize': 14,
       'arrow_size': 100,
       'line_width': 2.0
   }
   report_workflow.visualize(style_options=compact_style)
这将生成一个图形化的 DAG 图，清晰展示任务间的依赖关系。

步骤 5：提交工作流并获取结果
--------------------------

使用 `submit()` 方法将工作流提交到 Maze 集群。

.. code-block:: python

   print("\n🚀 [Step 3] Submitting workflow to server...")
   try:
       run_handle = report_workflow.submit(mode="local")  # 使用本地模式
       print(f"✅ [Step 3] Workflow submitted. Run Handle: {run_handle}\n")
   except (ValueError, RuntimeError) as e:
       print(f"❌ [Step 3] Workflow validation or submission failed: {e}")
运行模式说明：

mode="local"：在本地执行，用于开发调试。
mode="server"：提交到分布式集群执行。
步骤 6：等待并获取最终结果
------------------------

使用 `get_task_result()` 方法获取任务的执行结果。

.. code-block:: python

   print("🚀 [Step 4] Waiting for final task result...")
   result_info = run_handle.get_task_result(final_task_id, wait=True, timeout=300)

   print("\n🚀 [Step 5] Processing final result...")
   if result_info.get("task_status") == "finished":
       final_report = result_info.get("data", {}).get("final_report", "No report content found.")
       print("\n--- ✅ Final Report ---")
       print(final_report)
       print("----------------------\n")
   else:
       print(f"Task failed: {result_info.get('error')}")
预期输出：
.. code-block:: text

--- ✅ Final Report --- --- FINAL REPORT --- Initial report generated by MazeBot. Section: Data Analysis - Analysis complete. Section: Summary - Summary complete.
步骤 7：展示执行摘要
您可以调用 display_summary() 查看本次运行的统计信息：

.. code-block:: python

run_handle.display_summary()

步骤 8：清理资源（可选）
------------------------

提交完成后，建议清理服务器上的运行资源：

.. code-block:: python

   print(f"\n🚀 [Step 6] Cleaning up server resources...")
   if run_handle.destroy():
       print("✅ [Step 6] Cleanup successful.")
✅ 总结
通过这个示例，您已经完整体验了 Maze 的核心功能：

使用 @task 定义可调度的任务
使用 add_task() 和 f"{task_id}.output.{field}" 构建 DAG
任务自动并行执行（add_analysis 和 add_summary）
提交工作流并同步获取结果
下一步，您可以尝试将 mode 改为 "server"，并在分布式集群中运行此工作流，体验 Maze 的可扩展性。

您可以在项目根目录创建 quick_start_demo.py 文件，将上述代码片段组合起来运行。